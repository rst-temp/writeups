**–ó–∞–¥–∞–Ω–∏–µ:**

–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ñ–ª–∞–≥, –Ω—É–∂–Ω–æ —É—Å–ø–µ—Ç—å —Å–æ–±—Ä–∞—Ç—å –≤–µ—Å—å –ø–∞–∑–ª –∑–∞ 1 –º–∏–Ω—É—Ç—É.  
–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∞–∑–ª–æ–≤: 16 —à—Ç.

–ê–¥—Ä–µ—Å: http://31.207.77.216:4006

---
**–†–µ—à–µ–Ω–∏–µ:**

–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ—Ç–∞–ª–µ–π –ø–∞–∑–ª–∞ –Ω–µ–±–æ–ª—å—à–æ–µ, —Å–æ–±–∏—Ä–∞–µ–º –ø–∞–∑–ª –æ–¥–Ω–æ–π —Ä—É–∫–æ–π –∏ –ø–æ–ª—É—á–∞–µ–º —Ñ–ª–∞–≥:

![–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ](https://raw.githubusercontent.com/rst-temp/CTF/refs/heads/main/writeups/bug-makers/assets/Screenshot_1.png)

–°–∫—Ä–∏–ø—Ç –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏:

```python
import requests, base64, cv2, numpy as np
from PIL import Image
import io, time
from urllib.parse import urljoin

class PuzzleSolver:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
    
    def start_new_game(self):
        response = self.session.get(urljoin(self.base_url, '/api/new-game'))
        return response.json()
    
    def check_solution(self, solution):
        response = self.session.post(urljoin(self.base_url, '/api/check-solution'), json={'solution': solution})
        return response.json()
    
    def base64_to_cv2(self, base64_string):
        if 'base64,' in base64_string:
            base64_string = base64_string.split('base64,')[1]
        img_data = base64.b64decode(base64_string)
        img = Image.open(io.BytesIO(img_data))
        return cv2.cvtColor(np.array(img), cv2.COLOR_RGB2BGR)
    
    def solve_puzzle(self, game_data):
        reference_img = self.base64_to_cv2(game_data['originalImage'])
        pieces_data = game_data['puzzle']
        grid_size = game_data['gridSize']
        piece_size = game_data['pieceSize']
        
        best_matches = []
        for piece in pieces_data:
            piece_img = self.base64_to_cv2(piece['image'])
            result = cv2.matchTemplate(reference_img, piece_img, cv2.TM_CCOEFF_NORMED)
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
            x, y = max_loc
            grid_x = int(round(x / piece_size))
            grid_y = int(round(y / piece_size))
            if 0 <= grid_x < grid_size and 0 <= grid_y < grid_size and max_val > 0.8:
                best_matches.append({'id': piece['id'], 'position': (grid_x, grid_y), 'score': max_val})
        
        grid = [[None for _ in range(grid_size)] for _ in range(grid_size)]
        used_pieces = set()
        best_matches.sort(key=lambda x: x['score'], reverse=True)
        
        for match in best_matches:
            x, y = match['position']
            if match['id'] not in used_pieces and grid[y][x] is None:
                grid[y][x] = match['id']
                used_pieces.add(match['id'])
        
        empty_positions = [(x, y) for y in range(grid_size) for x in range(grid_size) if grid[y][x] is None]
        unused_pieces = [p for p in pieces_data if p['id'] not in used_pieces]
        
        for (x, y), piece in zip(empty_positions, unused_pieces):
            grid[y][x] = piece['id']
        
        solution = []
        for y in range(grid_size):
            for x in range(grid_size):
                solution.append(grid[y][x] if grid[y][x] else pieces_data[0]['id'])
        
        return solution
    
    def run(self):
        for attempt in range(20):
            game_data = self.start_new_game()
            if not game_data.get('success'):
                continue
            
            solution = self.solve_puzzle(game_data)
            result = self.check_solution(solution)
            
            if result.get('success'):
                print(f"üéâ –§–ª–∞–≥: {result.get('flag')}")
                return result.get('flag')
            
            time.sleep(1)
        return None

if __name__ == "__main__":
    solver = PuzzleSolver("http://31.207.77.216:4006")
    solver.run()
```
